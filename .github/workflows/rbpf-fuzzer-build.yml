name: RBPF Fuzzer Build Test

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

jobs:
  build-rbpf-fuzzer:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout autarkie repository
      uses: actions/checkout@v4

    - name: Install Rust
      uses: dtolnay/rust-toolchain@nightly

    - name: Install cargo-fuzz
      run: cargo install cargo-fuzz

    - name: Clone sbpf repository
      run: |
        cd /tmp
        git clone https://github.com/anza-xyz/sbpf
        cd sbpf

    - name: Remove Cargo.lock and add dependencies
      run: |
        cd /tmp/sbpf
        rm -f Cargo.lock
        cargo add autarkie --path ${{ github.workspace }}/autarkie --features derive --features libfuzzer
        cargo add serde --features derive

    - name: Define Grammar in lib.rs
      run: |
        cd /tmp/sbpf
        cat >> src/lib.rs << 'EOF'

        /// An EBPF instruction
        #[derive(serde::Serialize, serde::Deserialize, autarkie::Grammar, Debug, Clone)]
        pub struct FuzzInsn {
            /// Operation code.
            pub opc: u8,
            /// Destination register operand.
            pub dst: u8,
            /// Source register operand.
            pub src: u8,
            /// Offset operand.
            pub off: i16,
            /// Immediate value operand.
            pub imm: i64,
        }
        /// Autarkie's FuzzData
        #[derive(serde::Serialize, serde::Deserialize, autarkie::Grammar, Debug, Clone)]
        pub struct FuzzData {
            // list of instructions.
            pub insns: Vec<FuzzInsn>,
            // Initial data for the interpreter's Stack
            pub mem: Vec<u8>
        }

        /// Implement necessary traits for LibAFL
        autarkie::fuzz_libfuzzer!(FuzzData);
        EOF

    - name: Create fuzzing harness
      run: |
        cd /tmp/sbpf
        cargo fuzz add autarkie_harness

    - name: Write harness code
      run: |
        cd /tmp/sbpf
        cat > fuzz/fuzz_targets/autarkie_harness.rs << 'EOF'
        #![no_main]
        use libfuzzer_sys::fuzz_target;
        use solana_sbpf::{FuzzData, FuzzInsn};
        use solana_sbpf::{
            ebpf,
            elf::Executable,
            insn_builder::IntoBytes,
            memory_region::MemoryRegion,
            program::{BuiltinFunction, BuiltinProgram, FunctionRegistry, SBPFVersion},
            verifier::{RequisiteVerifier, Verifier},
        };
        use test_utils::{create_vm, TestContextObject};

        fn to_bytes(insns: &[FuzzInsn]) -> Vec<u8> {
            let mut data = vec![];
            for insn in insns {
                data.extend([
                    insn.opc,
                    insn.src << 4 | insn.dst,
                    insn.off as u8,
                    (insn.off >> 8) as u8,
                    insn.imm as u8,
                    (insn.imm >> 8) as u8,
                    (insn.imm >> 16) as u8,
                    (insn.imm >> 24) as u8,
                ]);
            }
            data
        }

        fuzz_target!(|data: &[u8]| {
            let Ok(fuzz_data) = bincode::deserialize::<FuzzData>(data) else {
                return;
            };
            let prog = to_bytes(&fuzz_data.insns);
            let config = solana_sbpf::vm::Config::default();
            let function_registry = FunctionRegistry::default();
            let syscall_registry = FunctionRegistry::<BuiltinFunction<TestContextObject>>::default();

            if RequisiteVerifier::verify(
                &prog,
                &config,
                SBPFVersion::V3,
                &function_registry,
                &syscall_registry,
            )
            .is_err()
            {
                // verify please
                return;
            }

            #[allow(unused_mut)]
            let mut executable = Executable::<TestContextObject>::from_text_bytes(
                &prog,
                std::sync::Arc::new(BuiltinProgram::new_loader(config)),
                SBPFVersion::V3,
                function_registry,
            )
            .unwrap();
            let mut interp_mem = fuzz_data.mem.clone();
            let mut interp_context_object = TestContextObject::new(1 << 16);
            let interp_mem_region = MemoryRegion::new_writable(&mut interp_mem, ebpf::MM_INPUT_START);
            create_vm!(
                interp_vm,
                &executable,
                &mut interp_context_object,
                interp_stack,
                interp_heap,
                vec![interp_mem_region],
                None
            );
            #[allow(unused)]
            let (_interp_ins_count, interp_res) = interp_vm.execute_program(&executable, true);

            #[cfg(all(not(target_os = "windows"), target_arch = "x86_64"))]
            if executable.jit_compile().is_ok() {
                let mut jit_mem = fuzz_data.mem;
                let mut jit_context_object = TestContextObject::new(1 << 16);
                let jit_mem_region = MemoryRegion::new_writable(&mut jit_mem, ebpf::MM_INPUT_START);
                create_vm!(
                    jit_vm,
                    &executable,
                    &mut jit_context_object,
                    jit_stack,
                    jit_heap,
                    vec![jit_mem_region],
                    None
                );
                let (_jit_ins_count, jit_res) = jit_vm.execute_program(&executable, false);
                if format!("{:?}", interp_res) != format!("{:?}", jit_res) {
                    // spot check: there's a meaningless bug where ExceededMaxInstructions is different due to jump calculations
                    if format!("{:?}", interp_res).contains("ExceededMaxInstructions")
                        && format!("{:?}", jit_res).contains("ExceededMaxInstructions")
                    {
                        return;
                    }
                    panic!("Expected {:?}, but got {:?}", interp_res, jit_res);
                }
                if interp_res.is_ok() {
                    // we know jit res must be ok if interp res is by this point
                    if interp_context_object.remaining != jit_context_object.remaining {
                        panic!(
                            "Expected {} insts remaining, but got {}",
                            interp_context_object.remaining, jit_context_object.remaining
                        );
                    }
                    if interp_mem != jit_mem {
                        panic!(
                            "Expected different memory. From interpreter: {:?}\nFrom JIT: {:?}",
                            interp_mem, jit_mem
                        );
                    }
                }
            }
        });
        EOF

    - name: Update fuzz Cargo.toml to use autarkie's libfuzzer
      run: |
        cd /tmp/sbpf/fuzz
        # Remove the standard libfuzzer-sys line
        sed -i '/^libfuzzer-sys = "0\./d' Cargo.toml
        # Add autarkie's libfuzzer from local path with package rename
        # The package name is autarkie_libfuzzer, but we want it available as libfuzzer-sys
        cargo add autarkie_libfuzzer --path ${{ github.workspace }}/libafl_libfuzzer --rename libfuzzer-sys

    - name: Add bincode dependency to fuzz target
      run: |
        cd /tmp/sbpf/fuzz
        cargo add bincode@1

    - name: Build the fuzzer
      run: |
        cd /tmp/sbpf
        CARGO_PROFILE_RELEASE_LTO=false AUTARKIE_GRAMMAR_SRC=/tmp/sbpf cargo fuzz build autarkie_harness

    - name: Verify fuzzer binary exists
      run: |
        ls -lh /tmp/sbpf/fuzz/target/x86_64-unknown-linux-gnu/release/autarkie_harness
        echo "RBPF fuzzer built successfully!"
